#include <iostream>
#include <Windows.h>
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

void gotoxy(int x, int y)
{
	COORD pos = { x - 1, y - 1 };
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}

void main()
{
	//a = -1;
	//여기서 사용된 - 기호는 언뜻 보기에 부호 연산자인 것 같지만 사실은 연산자가 아니다.
	//- 1이라는 상수의 한 부분일 뿐이며 부호를 바꾸는 동작을 하지는 않는다.

	// a=b=c=5;

	//a++++;
	//이렇게 쓰면 a가 2증가할 것 같지만 이 문장은 에러다.
	//혹시 괄호를 빼먹어서 컴파일러가 헷갈리는가 싶어서(a++)++요렇게 해도 마찬가지고
	//+ 가 한꺼번에 너무 많이 와서 그런가 싶어 ++a++같이 해도 역시 에러다.
	//왜냐하면 a는 변수이고 좌변값이지만 a를 1증가시킨 결과는 정수 상수이지
	//더 이상 좌변값이 아니기 때문이다.
	// ++ 연산자를 전위형으로 사용하여 ++++a; 라고 쓰는 것은 가능하지만 역시 일반적이지 않다. 

	//증감 연산은 아주 흔한 연산이며 CPU도 기계어 차원의 증감 명령을 별도로 가지고 있다.
	//어떤 값에 1을 더해 다시 대입하는 a = a + 1(어셈블리로 ADD[a], 1)보다
	//값을 1증가시키는 a++(어셈블리로 INC[a])이 속도도 더 빠르고 메모리도 적게 차지한다.
	//그러나 C언어 차원에서 a = a + 1과 a++은 별 차이가 없는데 
	//왜냐하면 컴파일러가 a = a + 1을 a++로 바꿔서 컴파일하기 때문이다

	// &&, || 이항 연산자는 교환 법칙이 성립하므로 좌우 조건식을 바꾸어도 결과는 동일하다. (a == 3 || a == 5)
	 // 조건문과 (a == 5 || a == 3) 조건문이 아무 차이가 없다는 것을 직관적으로 이해할 수 있을 것이다. 
	 // 그러나 쇼트 서키트 기능을 고려하면 함부로 교환 법칙을 적용해서는 안된다. 다음 문장은 아주 위험하다.
	// if (b/a == 3 && a != 0) 명령;
	// 쇼트 서키트의 지원을 받으려면 a가 0이 아닌지 점검하는 조건식이 왼쪽에 와야 한다.
	// 또 이런 경우를 가정해 보자. 변수값을 평가하는 단순 조건A와 조건 판단에 시간이 많이 걸리는 조건B가 있다고 하자.
	// B는 지구 반대편에 있는 웹 서버가 동작중인지 점검한다거나 데이터 베이스의 총 용량이 초과되었는지를 점검하는 조건식이며 평가하는데 시간이 아주 많이 걸린다.
	// 이 두 조건을 논리 연산자로 연결할 때는 (A && B)나 (A || B)로 써야 한다.
	// 또 반드시 실행해야 할 조건도 가급적 앞쪽에 배치해야 한다.
	// if (a == 8 || (ch=getch()) != ' ') {
		 // switch (ch) {
			  // ....
		 // }
	// }
	// 원래 의도는 a가 8이고 입력받은 문자 ch가 공백이 아니면 ch에 따른 분기를 하고자 하는 것인데
	 // a가 8이면 getch가 아예 호출되지도 않으므로 ch가 쓰레기값을 가지게 되며 이후 동작은 예측할 수 없게 된다. 
	// getch는 반드시 호출되어야 하므로 조건문의 순서를 바꾸어야 하며
	 // 그보다 더 좋은 코드는 ch=getch() 호출문을 if문 이전으로 옮기는 것이다.

	{

		int score;
		score = 86 + 65 + 92 + 88;
		printf("총점=%d, 평균=%d\n", score, score / 4);

	}

	{

		int i;
		for (i = 1; i <= 75; i = i + 1) {
			gotoxy(i, 10);
			if (i % 2 == 0) {
				puts(" __@");
			}
			else {
				puts(" ^^@");

			}
		}
	}
	// 이 문장은 C를 처음 공부하는 사람들이 가장 많이 실수하는 부분이다. 문자 배열은 문자열을 저장할 수 있지만 이런 식으로 문자열을 대입할 수는 없다.
	// 왜냐하면 배열의 이름인 str은 좌변값이 아니기 때문이다. 좌변값에 대해 좀 더 정리를 하자면 배열 요소는 좌변값이지만
	// 배열은 좌변값이 아니며 포인터 변수 ptr이 있을 때 *ptr은 좌변값이지만 &ptr은 좌변값이 아니다. 배열 요소도 일단은 좌변값이지만
	// 최종 요소만 좌변값이며 다차원 배열의 부분 배열은 배열 요소이기는 하지만 좌변값이 아니다.
	// 이런 복잡한 얘기는 배열과 포인터에서 다시 다룰 것이므로 여기서는 대입 연산자 왼쪽에는 좌변값만 올 수 있다고 알아 두도록 하자.

	{
		/*char str[12];
		str = "STRING";
*/
		const char str[12] = "STRING";
	}

	/// undefined & unspecified
//정의되지 않는다는 뜻의 Undefined라는 용어가 종종 등장한다.
//이 용어는 어떻게 될 지 알 수 없으며 결과를 책임질 수 없다는 뜻이다.
//따라서 컴파일러 제작사들은 정의되지 않은 동작에 대해서
//굳이 예외 처리를 할 필요가 없으며




///bitwise operation
// bitwise operators only handle unsigined integer.

// Bitwise assignment operators
//산술 할당 연산자(= )처럼, C++ 에는 변수를 쉽게 수정할 수 있도록 비트 할당 연산자를 제공한다.
//perator	Symbol	Form	Operation
//Left shift assignment <<= x <<= y	Shift x left by y bits
//Right shift assignment >>= x >>= y	Shift x right by y bits
//Bitwise OR assignment	l = x l = y	Assign x \	y to x
//Bitwise AND assignment &= x &= y	Assign x & y to x
//Bitwise XOR assignment ^= x ^= y	Assign x ^ y to x
// 예를 들어, x = x << 1을 쓰는 대신 x <<= 1 을 쓸 수 있다.
//출처 : https://boycoding.tistory.com/163 [소년코딩]




/// shift operation
// 쉬프트 연산의 피연산자는 주로 부호없는 정수형이다. 실수형은 당연히 안된다.
//부호있는 정수형은 가능은 하지만 이 경우 동작이 조금 달라진다. 
//최상위에 있는 부호 비트는 쉬프트 대상에서 제외되는데 부호는 값이 아니기 때문에 유지하는 것이 옳다. 
//부호있는 정수에 대한 쉬프트 연산은 권장되지 않으며 실제로 의미를 가지는 경우도 드물다.

//쉬프트 연산이 곱셈에 비해 불리한 점은 2의 거듭승에 대해서만 곱셈이 가능하다는 점이다.
//2배, 4배, 8배, 16배 등만 할 수 있으며 3배, 17배 이런 연산은 할 수 없다.
//그러나 쉬프트 연산과 덧셈, 뺄셈을 잘 조합하면 이런 연산이 가능해지기도 한다.
//	3배 : a << 1 + a;
//9배 : a << 3 + a;
//15배 : a << 4 - a;
//.60배 : a << 6 - a << 2;

	{
		int i;
		printf("shift operation");
		// scanf("%d", &i);
		i = 35;
		printf("결과=%d\n", i << 1);
	}

	/// rotate operation
	/*회전 연산과 쉬프트 연산을 함께 사용하면 비트를 아주 섬세하게 제어할 수 있다.
		비트맵 이미지를 회전시킨다거나 변형할 때 각 점을 구성하는 비트들을 자유롭게 조작할 수 있다.
		두 연산은 CPU가 기계 차원에서 직접 지원하는 저수준 연산이므로 속도가 아주 빠르다.
		회전 연산의 특징은 원래 값으로 복구가 가능하다는 점이다.왼쪽으로 한칸 돌렸다가 오른쪽으로 다시 한칸 돌리면 제자리다.
		그래서 XOR 연산과 함께 암호화를 위해 자주 사용된다.*/
	{
		unsigned i = 0x12345678;
		printf("rotate opertaion %x\n", _rotl(i, 4));
	}

	// 다음 예제는 지금까지 배운 여러 가지 연산자를 골고루 사용하여 10진수를 16진수로 바꿔 출력한다. 
	// 0~255사이의 10진수는 8비트 크기를 가지며 상하위 4비트가 16진수 한 자리가 되어 두 자리의 16진수로 표기할 수 있다. 
	// 상하위 니블을 hi, low 변수에 분리하기 위해 >> 연산자와 & 연산자를 사용했다.
	// 상위에 있는 4비트값을 추출하려면 >> 연산자로 4회 쉬프트하면 되고 하위 4비트만을 남기려면 & 연산자로 상위 4비트를 마스크 오프시키면 된다.
	{
		int input;
		int low, hi;

		printf("10 -> 16\n");
		//scanf("%d", &input);
		input = 166;
		//if (input == -1) {
		//	break;
		//}
		hi = input >> 4;
		low = input & 0xf;
		printf("입력한 수의 16진 표기 = %c%c\n",
			hi + '0' + (hi > 9) * 7, low + '0' + (low > 9) * 7);
	}

	/// tri conditional operation
/*	i는 3이고 j는 4로 초기화되었으며 k는 삼항 조건 연산자로 i나 j중에 큰 값을 대입받는다.
		보다시피 i보다 j가 더 크게 초기화되었으므로 j가 선택될 것이다.
		? 연산자는 조건식(i > j)를 평가하여 i가 j보다 더 큰지 점검한다.
		점검 결과가 참이면 i를 리턴하고 그렇지 않으면 j를 리턴할 것이다.그래서 이 연산문은 두 변수 중 큰 값을 취한다.*/
	{
		int i = 3, j = 4, k;
		k = (i > j) ? i : j;
		printf("tri 큰 수=%d\n", k);

		k = (i > j) ? i : (j < 0) ? 0 : j; // k=(i > j) ? i:((j < 0) ? 0:j);

		int a = 6;
		printf("a는 6이%s다.", (a == 6) ? "" : " 아니");
	}

	// comma operator
	//쉼표 연산자는 쉼표 기호(, )를 사용하는데 모양만으로 보면 구두점같이 생겨서 연산자가 아닌 것처럼 보이기도 한다.
	//	하지만 분명히 연산자이다.피연산자로 양쪽에 두 개의 표현식을 취하며 좌변을 먼저 평가하고 우변을 평가한 후 우변의 연산 결과를 리턴한다.
	//	쉼표 연산자는 어떤 연산을 한다기보다는 두 연산식을 하나로 묶는 역할만 한다.
	{
		int i, j;
		j = (i = 3, i + 2);
		printf("i=%d, j=%d\n", i, j);

		//쉼표 연산자는 모든 연산자들 중에 우선 순위가 가장 늦다. 
		// 이렇게 쓰면 j와 i는 3이 되고 i + 2는 평가는 되지만 아무도 값을 대입받지 않으므로 버려진다.
		j = i = 3, i + 2;
		printf("i=%d, j=%d\n", i, j);

		// 쉼표 연산자가 반드시 필요한 경우는{ }의 도움없이 두 개 이상의 문장을 하나로 묶어야 할 때와
		// for문에서 제어 변수 두 개를 사용하고자 할 때이다.다음 예제를 실행해 보자.
		for (i = 1, j = 1; i < 5; i++, j += 2) {
			printf("i=%d", i);
			printf(",j=%d\n", j); // printf("i=%d",i),printf(",j=%d\n",j); 로도 가능하지만 일반적이지않음

		}
	}
	//  while (scanf("%d",&input), input != num) 이라고 쓰면 두 문장이 하나로 합쳐진다. 
	// 좀 억지스러워 보이지만 어쩔 수 없이 이렇게 해야 하는 경우도 있을 수 있다.

/// size of
	//sizeof 연산자는 피연산자의 총 크기를 바이트 단위로 계산한다.
	//	int array[34]라는 배열이 있을 때 sizeof(array)는 34 * 4 = 136이다.
	//	sizeof(array) / sizeof(array[0])

	/// precedence
	//  곱셈은 덧셈보다 순위가 높지만 대입 연산자나 복합 대입 연산자는 덧셈보다 순위가 더 낮다.
	// 괄호 안쓰면 가독성 떨어짐
	{
		int a(4);
		a *= 2 + 3; // 20
		cout << a << endl;

		/*		unsigned int b = 3
				if (b & 2 != 0) {
					cout << b << endl;
				}*/ // 	& 연산보다 관계 연산자가 순위가 더 높기 때문에 의도에서 벗어남.
				// ((b & 2) != 0)
	}

	// if (ch=getch() == 'x') //  ==이 =보다 우선 순위가 높아서 getch()와 'x'가 먼저 비교되고 비교 결과가 ch에 대입

	/// 결합순서
	//a = b + c + d;
	//대부분의 이항 연산자들은 왼쪽 우선 순위를 가지기 때문에 수식에 등장하는 순서대로 실행된다.

	//   	a = b = c = 3;
	//이 대입문은 a, b, c 모두 3을 대입하는데 대입 연산자는 오른쪽 우선이다.
	//	즉 제일 오른쪽에 있는 c = 3이 가장 먼저 실행되고 차례대로 b = c, a = b가 대입된다.
	//	만약 대입 연산자가 왼쪽 우선 순위를 가지게 되면 a = b, b = c, c = 3 순서대로 실행되어 a는 b의 쓰레기값을 가질 것이고
	//	b는 c의 쓰레기값을 가지며 결국 3이 되는 것은 c밖에 없을 것이다.

	//	(double)(unsigned)i;
	//	그외 단항 연산자들은 모두 오른쪽 우선 순위를 가진다.
	//(unsigned)가 먼저 실행되어 i의 부호를 없앤 후(double)이 실행되어 실수 타입으로 바꾼다.

	/// 산술변환
	// 대입 연산시 좌변의 타입을 따른다. 값을 대입받을 변수의 능력치를 초과할 수는 없기 때문에 대입되는 값이 변수보다 더 크면 잘라낸다.
	// 함수 호출시 실인수와 형식인수의 타입이 다르면 형식인수의 타입을 따라간다.
	// 수식내에서 사용될 경우 char, unsigned char, enum형은 int형으로 자동 확장되며 float형은 double형으로 확장된다.
		//만약 ⑤번 규칙이 없다면 short a = 20000, b = 30000일 때 int c = a + b의 결과가 50000이 되지 않을 것이다.
		//short끼리 더한 결과가 short가 되어 버리면 연산중에 오버 플로우가 발생하여

	/// 인수
	//변수를 선언할 때 같은 타입은 int a, b, c, d; 형식으로 한꺼번에 선언할 수 있으므로
	//int func(int a, b, c, d)

	/// return
	// 함수는 한 번에 하나의 리턴값만 돌려줄 수 있기 때문에 타입만 맞다면 수식내에서 함수를 바로 쓸 수 있는 것이다. 
	// gotoxy(Max(a, b), Add(c, d));
	// Add(Add(Add(Add(1, 2), 3), 4), 5);

	//■ 함수(function) : 특정 계산을 수행하며 리턴값이 있다. 
	/*반드시 수식내에서만 사용할 수 있으며 함수 단독으로 문장을 구성할 수 없다.
		이 경우는 수학적 의미의 함수와 거의 유사하므로 적합한 용어 사용예라 할 수 있다.
	■ 프로시저(procedure) : 특정 작업을 수행하며 리턴값이 없다.
		리턴값이 없기 때문에 수식내에서는 사용할 수 없으며 단독으로 문장을 구성할 수는 있다.
		C의 void 함수가 이에 해당한다.}*/


	getchar();
}
