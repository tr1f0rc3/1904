람다 큐 예제 안에 변수를 다 null로 만들지 않으면 오류남. delete해도..  왜지? null땜에 더 못지우나?

built in array는 iterator지원 안하는데 std::array는 지원함.
관리되는 함수를 클래스 내 만들 경우 비용이 큼. 람다함수를 쓰면 그런 비용이 사라짐.
const satatic 하면 클래스 내부에서 초기화됨.

static은 실행단계에서 확인해야함.
inline 함수는 매크로 함수인데,매크로 함수와 일반함수의 차이점은 매크로 함수는 컴파일하기전에 해당함수 호출부분에 함수가 미리 들어가 있습니다.

return T(a+b)과 같이 return 하는 이유는 복사생성자 대신 이동생성자 이용하기 위함.

함수 인자를 레퍼런스 타입으로 받으면 무조건 4바이트임. 주소.

템플릿을 헤더 안에 정의해야만 하더라도 inline 유무는 있음

가상함수는 못만듦. 템플릿은 컴파일타임에 구체화되어야 하는데, 가상함수는 런타임에 알 수 있기 때문.

템플릿 내 람다에서 auto로 타입 추론 가능

for_each garbage가 잘생김. 모든 언어에서. msvc에서만 사용 가능하므로 쓰지 말 것.

unique ptr은 일반 포인터와 유사. 값복사, 복사생성자는 가능.

shared ptr은 원본 지워도 됨.,


